public class Main {
    public static void main(String[] args) {
        System.out.println("Hello");

        // WHY TEST?

        // catch a possible defect
        // provides confidence in our code (it does what we say it does)
        // save time and money
        // devs will have to spend more time going back and fixing defects after feature goes live (which costs money)
        // if a feature goes live and goes wrong it could cost a lot of money (lawsuits)
        // re-usability of code (code that is reusable is more testable)
        // documentation
        // later down the line when people use our code/feature, tests act as documentation for what that code does


        // unit testing
        // testing individual modules/components to check they work in isolation
        // integration testing
        // how the components/function/modules interact with those around it
        // functions inside functions
        // multiple components (in a React app for example)
        // e2e testing
        // testing the whole application as a cohesive unit
        // cypress for JavaScript
        // tested calculators


        // TDD
        // Test Driven Development
        // write tests first, then write code to make the tests pass
        // once all tests go green and pass, we have finished the ticket/task
        // don't forget cases (e.g. negative tests)
        // don't leave them out if working to a deadline
        // can be easily split into testing and dev section (one person tests, one write code to pass tests)
        // can objectively write the tests without bias after writing the code

    }

    // WHY TEST?

    // catch a possible defect
    // provides confidence in our code (it does what we say it does)
    // save time and money
    // devs will have to spend more time going back and fixing defects after feature goes live (which costs money)
    // if a feature goes live and goes wrong it could cost a lot of money (lawsuits)
    // re-usability of code (code that is reusable is more testable)
    // documentation
    // later down the line when people use our code/feature, tests act as documentation for what that code does


    // unit testing
    // testing individual modules/components to check they work in isolation
    // integration testing
    // how the components/function/modules interact with those around it
    // functions inside functions
    // multiple components (in a React app for example)
    // e2e testing
    // testing the whole application as a cohesive unit
    // cypress for JavaScript
    // tested calculators


    // TDD
    // Test Driven Development
    // write tests first, then write code to make the tests pass
    // once all tests go green and pass, we have finished the ticket/task
    // don't forget cases (e.g. negative tests)
    // don't leave them out if working to a deadline
    // can be easily split into testing and dev section (one person tests, one write code to pass tests)
    // can objectively write the tests without bias after writing the code

}
